# Software Requirements Specification
# RuleTimeR: A Rule Ensemble-based Time-to-Event Regression Module

## 1. Introduction

### 1.1 Purpose
This Software Requirements Specification (SRS) document describes the functional and non-functional requirements for RuleTimeR, a Python module implementing rule ensemble methods for time-to-event (survival) analysis, including support for competing risks and multi-state modeling. The module aims to combine the interpretability of rule-based methods with the predictive power of ensemble techniques for time-to-event data.

### 1.2 Scope
RuleTimeR will provide researchers and data scientists with tools to build interpretable predictive models for time-to-event outcomes. The module will focus on implementing RuleFit-like approaches adapted for survival analysis, competing risks, and multi-state models. It will support data preprocessing, model training, evaluation, and visualization.

### 1.3 Definitions, Acronyms, and Abbreviations
- **Time-to-event analysis**: Statistical methods for analyzing the expected duration of time until one or more events occur
- **Survival analysis**: Analysis of time until a single event occurs
- **Competing risks**: Analysis where subjects may experience one of several distinct event types
- **Multi-state model**: Models transitions between multiple states over time
- **Rule ensemble**: Machine learning methods that combine decision rules to create interpretable prediction models
- **RuleFit**: A specific algorithm that combines rules extracted from decision trees with linear terms
- **Hazard function**: The instantaneous rate of occurrence of the event at time t
- **Cumulative incidence function (CIF)**: The probability of experiencing a specific event by time t
- **Transition probability**: The probability of moving from one state to another within a given time interval

### 1.4 References
1. Friedman, J. H., & Popescu, B. E. (2008). Predictive learning via rule ensembles. The Annals of Applied Statistics, 2(3), 916-954.
2. Fine, J. P., & Gray, R. J. (1999). A proportional hazards model for the subdistribution of a competing risk. Journal of the American Statistical Association, 94(446), 496-509.
3. Andersen, P. K., & Keiding, N. (2002). Multi-state models for event history analysis. Statistical Methods in Medical Research, 11(2), 91-115.

### 1.5 Overview
The remainder of this document is organized as follows: Section 2 provides a general description of the module. Section 3 details specific functional requirements, including data handling, model implementation, and output capabilities. Section 4 covers non-functional requirements such as performance, usability, and compatibility. Section 5 outlines external interface requirements.

## 2. Overall Description

### 2.1 Product Perspective
RuleTimeR will be a standalone Python module that can be integrated into existing data science workflows. It will complement other survival analysis packages by providing uniquely interpretable models based on rule ensembles. The module will be compatible with the scikit-learn API where possible, allowing integration with the broader Python data science ecosystem.

### 2.2 Product Functions
The main functions of RuleTimeR include:
- Preprocessing time-to-event data including handling of censoring and multiple states
- Generating rules from decision trees for time-to-event outcomes
- Training rule ensemble models for:
  - Standard survival analysis
  - Competing risks analysis
  - Multi-state modeling
- Model evaluation using appropriate metrics for each model type
- Visualizing model results and rule importance
- Explaining predictions for individual observations

### 2.3 User Characteristics
The expected users of RuleTimeR are:
- Data scientists with experience in survival analysis or time-to-event modeling
- Researchers in healthcare, epidemiology, reliability engineering, or other fields where time-to-event outcomes are common
- Users with intermediate Python skills and familiarity with machine learning libraries
- Users seeking interpretable models for time-to-event data analysis

### 2.4 Constraints
- The module must be compatible with Python 3.8+
- External dependencies should be limited to widely-used packages (numpy, pandas, scipy, scikit-learn)
- Models should be computationally efficient enough to run on standard hardware
- The implementation should prioritize correctness of statistical methods over computational speed

### 2.5 Assumptions and Dependencies
- Users have basic understanding of time-to-event analysis concepts
- Users can provide properly formatted time-to-event data
- The module will depend on scikit-learn for base decision tree implementations
- The module will depend on lifelines or similar packages for benchmark comparisons

## 3. Specific Requirements

### 3.1 Data Handling Requirements

#### 3.1.1 Data Input
- **REQ-DH-1**: Accept time-to-event data in various formats including:
  - DataFrames with time and event indicator columns
  - DataFrames with start time, end time, and event indicator columns
  - Specialized formats for competing risks (multiple event types)
  - Specialized formats for multi-state transitions
- **REQ-DH-2**: Handle right-censored observations
- **REQ-DH-3**: Support left-truncated observations
- **REQ-DH-4**: Handle interval-censored data
- **REQ-DH-5**: Support time-dependent covariates
- **REQ-DH-6**: Provide data validation to check for common issues in time-to-event data

#### 3.1.2 Data Preprocessing
- **REQ-DP-1**: Implement functions to check for and handle missing values
- **REQ-DP-2**: Support both numerical and categorical features
- **REQ-DP-3**: Provide preprocessing transformations specific to rule ensemble methods
- **REQ-DP-4**: Include methods to create discretized time bins for model fitting
- **REQ-DP-5**: Support train-test splitting that preserves time-to-event data structure

### 3.2 Rule Generation Requirements

#### 3.2.1 Rule Extraction
- **REQ-RG-1**: Extract rules from decision trees trained on time-to-event data
- **REQ-RG-2**: Support multiple methods for growing trees (e.g., survival trees, competing risk trees)
- **REQ-RG-3**: Include parameters to control rule complexity and quantity
- **REQ-RG-4**: Implement rule pruning methods to remove redundant or low-importance rules
- **REQ-RG-5**: Generate rules capturing nonlinear relationships and interactions

#### 3.2.2 Linear Term Handling
- **REQ-LT-1**: Include original linear terms alongside rules following the RuleFit approach
- **REQ-LT-2**: Support different strategies for combining rules and linear terms
- **REQ-LT-3**: Implement methods to handle collinearity between rules and linear terms

### 3.3 Model Implementation Requirements

#### 3.3.1 Standard Survival Analysis
- **REQ-SA-1**: Implement rule-based Cox proportional hazards model
- **REQ-SA-2**: Support parametric survival models with rule ensembles (e.g., Weibull, exponential)
- **REQ-SA-3**: Include accelerated failure time models with rule ensembles
- **REQ-SA-4**: Provide baseline hazard estimation for absolute risk prediction
- **REQ-SA-5**: Support stratification by categorical variables

#### 3.3.2 Competing Risks Analysis
- **REQ-CR-1**: Implement Fine-Gray subdistribution hazard model with rule ensembles
- **REQ-CR-2**: Support cause-specific hazard models with rule ensembles
- **REQ-CR-3**: Provide cumulative incidence function estimation for each competing event
- **REQ-CR-4**: Allow for different rule sets for different competing events
- **REQ-CR-5**: Implement methods for evaluating prediction accuracy in competing risks setting

#### 3.3.3 Multi-state Modeling
- **REQ-MS-1**: Support general multi-state models with rule ensembles
- **REQ-MS-2**: Implement modeling approaches for specific multi-state structures (e.g., illness-death models)
- **REQ-MS-3**: Allow for different rule sets for different state transitions
- **REQ-MS-4**: Provide methods for estimating transition probabilities
- **REQ-MS-5**: Support calculation of length of stay in each state

#### 3.3.4 Training and Regularization
- **REQ-TR-1**: Implement L1 regularization for rule selection
- **REQ-TR-2**: Support L2 regularization for parameter shrinkage
- **REQ-TR-3**: Include elastic net regularization option
- **REQ-TR-4**: Implement efficient training algorithms suitable for high-dimensional rule spaces
- **REQ-TR-5**: Support sample weighting during model training
- **REQ-TR-6**: Provide cross-validation methods for hyperparameter tuning

### 3.4 Model Output and Interpretation Requirements

#### 3.4.1 Prediction Capabilities
- **REQ-PC-1**: Generate survival probability predictions at specified time points
- **REQ-PC-2**: Predict cumulative incidence functions for competing risks
- **REQ-PC-3**: Estimate transition probabilities for multi-state models
- **REQ-PC-4**: Support prediction of conditional survival probabilities
- **REQ-PC-5**: Provide confidence intervals or prediction intervals where applicable

#### 3.4.2 Model Interpretation
- **REQ-MI-1**: Calculate and visualize rule importance
- **REQ-MI-2**: Generate partial dependence plots for rules and features
- **REQ-MI-3**: Identify interactions captured by rules
- **REQ-MI-4**: Provide patient-specific rule activation patterns
- **REQ-MI-5**: Generate natural language descriptions of key rules

#### 3.4.3 Evaluation Metrics
- **REQ-EM-1**: Implement concordance index for survival models
- **REQ-EM-2**: Support time-dependent AUC calculation
- **REQ-EM-3**: Include Brier score for prediction accuracy
- **REQ-EM-4**: Implement specialized metrics for competing risks models
- **REQ-EM-5**: Support calibration assessment for predicted probabilities
- **REQ-EM-6**: Provide appropriate evaluation metrics for multi-state models

### 3.5 Visualization Requirements
- **REQ-VZ-1**: Generate Kaplan-Meier curves for survival analysis
- **REQ-VZ-2**: Plot cumulative incidence functions for competing risks
- **REQ-VZ-3**: Visualize state transition diagrams for multi-state models
- **REQ-VZ-4**: Create rule importance plots
- **REQ-VZ-5**: Generate heat maps of rule activation patterns
- **REQ-VZ-6**: Plot predicted vs. observed survival curves for model validation

## 4. Non-functional Requirements

### 4.1 Performance Requirements
- **REQ-PF-1**: The module should be able to handle datasets with at least 100,000 observations
- **REQ-PF-2**: Training time should scale no worse than O(n log n) with respect to sample size
- **REQ-PF-3**: Prediction time should be efficient enough for real-time applications
- **REQ-PF-4**: Memory usage should be optimized for large rule sets
- **REQ-PF-5**: Support parallel processing for computationally intensive operations

### 4.2 Usability Requirements
- **REQ-US-1**: Provide a scikit-learn compatible API where appropriate
- **REQ-US-2**: Include comprehensive documentation with examples
- **REQ-US-3**: Implement informative error messages for common issues
- **REQ-US-4**: Provide sensible default parameters for most use cases
- **REQ-US-5**: Include visualization functions with reasonable defaults

### 4.3 Reliability Requirements
- **REQ-RL-1**: Ensure numerical stability in hazard and survival probability calculations
- **REQ-RL-2**: Include checks for violations of model assumptions
- **REQ-RL-3**: Handle edge cases gracefully (e.g., no events in a given group)
- **REQ-RL-4**: Implement proper error handling and recovery mechanisms
- **REQ-RL-5**: Include unit tests with high coverage

### 4.4 Compatibility Requirements
- **REQ-CP-1**: Ensure compatibility with Python 3.8+
- **REQ-CP-2**: Support major operating systems (Windows, Linux, macOS)
- **REQ-CP-3**: Ensure compatibility with standard scientific Python stack
- **REQ-CP-4**: Support integration with visualization tools (matplotlib, seaborn, plotly)
- **REQ-CP-5**: Maintain compatibility with pandas data structures

## 5. External Interface Requirements

### 5.1 API Interface
- **REQ-API-1**: Provide a consistent API across different model types
- **REQ-API-2**: Implement fit, predict, and score methods following scikit-learn conventions
- **REQ-API-3**: Support serialization of trained models
- **REQ-API-4**: Include functions to export models to other formats when possible

### 5.2 File Formats
- **REQ-FF-1**: Support CSV and other common tabular data formats for input
- **REQ-FF-2**: Provide methods to export results to standard formats
- **REQ-FF-3**: Support saving and loading models
- **REQ-FF-4**: Include options for exporting visualizations in various formats

## 6. Other Requirements

### 6.1 Documentation Requirements
- **REQ-DC-1**: Provide detailed API documentation
- **REQ-DC-2**: Include tutorials covering common use cases
- **REQ-DC-3**: Provide theoretical background on implemented methods
- **REQ-DC-4**: Document limitations and assumptions of each method
- **REQ-DC-5**: Include example notebooks demonstrating usage

### 6.2 Testing Requirements
- **REQ-TS-1**: Implement unit tests for all key functionality
- **REQ-TS-2**: Include integration tests for end-to-end workflows
- **REQ-TS-3**: Test with benchmark datasets from survival analysis literature
- **REQ-TS-4**: Validate results against established implementations where possible
- **REQ-TS-5**: Include performance benchmarks

## 7. Implementation Considerations

### 7.1 Priority of Requirements
High priority:
- Core rule generation functionality
- Standard survival analysis implementation
- Basic visualization and interpretation features

Medium priority:
- Competing risks implementation
- Advanced model interpretation features
- Performance optimizations

Lower priority:
- Multi-state modeling
- Advanced visualization options
- Specialized data preprocessing features

### 7.2 Development Phases
1. Phase 1: Core functionality for standard survival analysis with rule ensembles
2. Phase 2: Support for competing risks analysis and enhanced interpretation tools
3. Phase 3: Multi-state modeling capabilities and advanced features
4. Phase 4: Optimization, extended documentation, and additional visualization options

## Appendix A: Example Use Cases

### Use Case 1: Predicting Patient Survival
A medical researcher wants to build an interpretable model to predict patient survival after a specific treatment. The researcher has data on patient demographics, lab values, treatment details, and survival times.

### Use Case 2: Analyzing Competing Causes of System Failure
A reliability engineer wants to analyze different causes of failure in a mechanical system. They have monitoring data leading up to failures and need to predict both the timing and the type of failure that might occur.

### Use Case 3: Modeling Disease Progression
A healthcare analyst wants to model the progression of a chronic disease through various stages. They have longitudinal data tracking patients as they move between disease states over time.

## Appendix B: Sample Code Examples

### Example 1: Basic Survival Analysis
```python
import ruletimer as rt
import pandas as pd

# Load and prepare data
data = pd.read_csv("patient_data.csv")
X = data.drop(columns=["time", "event"])
y = rt.Survival(data["time"], data["event"])

# Create and train model
model = rt.RuleSurvival(max_rules=100, alpha=0.05)
model.fit(X, y)

# Predict survival probability at specific time points
times = [6, 12, 24]  # months
survival_probs = model.predict_survival(X_new, times)

# Get rule importance
importance = model.rule_importance()
rt.plot_rule_importance(importance)
```

### Example 2: Competing Risks Analysis
```python
import ruletimer as rt
import pandas as pd

# Load and prepare data
data = pd.read_csv("failure_data.csv")
X = data.drop(columns=["time", "event_type"])
y = rt.CompetingRisks(data["time"], data["event_type"])

# Create and train model
model = rt.RuleCompetingRisks(max_rules=150, alpha=0.05)
model.fit(X, y)

# Predict cumulative incidence for each event type
times = [30, 60, 90]  # days
event_types = [1, 2]  # failure types
cif = model.predict_cumulative_incidence(X_new, times, event_types)

# Plot cumulative incidence functions
rt.plot_cumulative_incidence(model, X_new.iloc[0], event_types)
```

### Example 3: Multi-state Modeling
```python
import ruletimer as rt
import pandas as pd

# Load and prepare data
data = pd.read_csv("disease_progression.csv")
X = data.drop(columns=["start_time", "end_time", "start_state", "end_state"])
y = rt.MultiState(data["start_time"], data["end_time"], 
                 data["start_state"], data["end_state"])

# Define state transition structure
states = ["Healthy", "Mild", "Moderate", "Severe", "Death"]
transitions = [(0,1), (1,2), (2,3), (1,3), (2,4), (3,4)]
structure = rt.StateStructure(states, transitions)

# Create and train model
model = rt.RuleMultiState(structure, max_rules=200)
model.fit(X, y)

# Predict state occupation probabilities
times = [1, 3, 5, 10]  # years
state_probs = model.predict_state_occupation(X_new, times)

# Plot state transition diagram with predicted probabilities
rt.plot_state_transitions(model, X_new.iloc[0], time=5)
```

## Appendix C: Glossary

- **Rule**: A logical condition on features, typically in the form of "if [condition] then [prediction]"
- **Ensemble**: A combination of multiple models to improve predictive performance
- **Hazard function**: The instantaneous rate of an event occurring at a specific time
- **Survival function**: The probability of surviving beyond a certain time
- **Cumulative incidence function**: The probability of experiencing a specific event by a certain time
- **Multi-state model**: A model describing transitions between different states over time
- **Censoring**: Incomplete observation of the event time
- **Concordance index**: A measure of the predictive accuracy of a survival model
- **Regularization**: Techniques to prevent overfitting in statistical models